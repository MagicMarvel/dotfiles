{
    "get some data from stdio like `cin` in cpp": {
        "prefix": "pre-cin",
        "body": [
            "use std::io::stdin;",
            "",
            "macro_rules! read {",
            "    (\\$last_ident:ident \\$(,\\$idents:ident)*) => {{",
            "        #[allow(dead_code, non_camel_case_types)]",
            "        enum Idents{",
            "            \\$(\\$idents,)*",
            "            \\$last_ident",
            "        }",
            "        const COUNT: usize = Idents::\\$last_ident as usize + 1;",
            "        let read_ret: Vec<_> = read_to_vec(COUNT);",
            "        \\$last_ident = read_ret[0];",
            "        \\$(",
            "            \\$idents = read_ret[Idents::\\$idents as usize + 1];",
            "        )*",
            "    }};",
            "}",
            "",
            "#[allow(dead_code)]",
            "fn read_to_vec<T: std::str::FromStr>(n: usize) -> Vec<T>",
            "where",
            "    T::Err: std::fmt::Debug,",
            "{",
            "    use std::io;",
            "    let mut input = String::new();",
            "    io::stdin().read_line(&mut input).unwrap();",
            "    let mut s = input.split_whitespace();",
            "    let mut ret = Vec::new();",
            "    for _ in 1..=n {",
            "        ret.push(s.next().unwrap().parse().unwrap());",
            "    }",
            "    ret",
            "}",
            "",
            "#[allow(dead_code)]",
            "fn read_string() -> Vec<u8> {",
            "    let mut s = String::new();",
            "    stdin().read_line(&mut s).unwrap();",
            "    s.trim_end_matches(char::is_control).into()",
            "}",
            "",
            "$1"
        ]
    },
    "get the type from the variable": {
        "prefix": "typeof",
        "body": [
            "        // --------------------------得到一个变量的类型-------------------------------------",
            "trait TypeInfo {",
            "    fn type_name() -> String;",
            "    fn type_of(&self) -> String;",
            "}",
            "",
            "macro_rules! impl_type_info {",
            "    (\\$(\\$name:ident\\$(<\\$(\\$T:ident),+>)*),*) => {",
            "        \\$(impl_type_info_single!(\\$name\\$(<\\$(\\$T),*>)*);)*",
            "    };",
            "}",
            "",
            "macro_rules! mut_if {",
            "    (\\$name:ident = \\$value:expr, \\$(\\$any:expr)+) => {",
            "        let mut \\$name = \\$value;",
            "    };",
            "    (\\$name:ident = \\$value:expr,) => {",
            "        let \\$name = \\$value;",
            "    };",
            "}",
            "",
            "macro_rules! impl_type_info_single {",
            "    (\\$name:ident\\$(<\\$(\\$T:ident),+>)*) => {",
            "        impl\\$(<\\$(\\$T: TypeInfo),*>)* TypeInfo for \\$name\\$(<\\$(\\$T),*>)* {",
            "            fn type_name() -> String {",
            "                mut_if!(res = String::from(stringify!(\\$name)), \\$(\\$(\\$T)*)*);",
            "                \\$(",
            "                    res.push('<');",
            "                    \\$(",
            "                        res.push_str(&\\$T::type_name());",
            "                        res.push(',');",
            "                    )*",
            "                    res.pop();",
            "                    res.push('>');",
            "                )*",
            "                res",
            "            }",
            "            fn type_of(&self) -> String {",
            "                \\$name\\$(::<\\$(\\$T),*>)*::type_name()",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "impl<'a, T: TypeInfo + ?Sized> TypeInfo for &'a T {",
            "    fn type_name() -> String {",
            "        let mut res = String::from(\"&\");",
            "        res.push_str(&T::type_name());",
            "        res",
            "    }",
            "    fn type_of(&self) -> String {",
            "        <&T>::type_name()",
            "    }",
            "}",
            "",
            "impl<'a, T: TypeInfo + ?Sized> TypeInfo for &'a mut T {",
            "    fn type_name() -> String {",
            "        let mut res = String::from(\"&mut \");",
            "        res.push_str(&T::type_name());",
            "        res",
            "    }",
            "    fn type_of(&self) -> String {",
            "        <&mut T>::type_name()",
            "    }",
            "}",
            "",
            "macro_rules! type_of {",
            "    (\\$x:expr) => {",
            "        (&\\$x).type_of()",
            "    };",
            "}",
            "impl_type_info!(i32, i64, f32, f64, str, String, Vec<T>, Result<T,S>);",
            "",
            "// --------------------------得到一个变量的类型-------------------------------------"
        ]
    }
}
